<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title> Stackful Coroutine Async Story in Rust </title>

	<meta name="description" content="Another rust async story">
	<meta name="author" content="Xudong-Huang">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="reveal.js/css/reveal.css">
	<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<h1>Stackful Coroutine in Rust</h1>
				<h3>Another async story</h3>
				<p>
					<small>Created by <a href="https://github.com/Xudong-Huang">Xudong-Huang</a> </small>
				</p>
			</section>

			<section data-markdown>
				<script type="text/template">
					## Agenda
					* Stackful Generator
					* Stackful Coroutine
					* Async Io
					* Sync Primitives
					* Timer Management
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
					## Agenda - continued
					* Coroutine Cancellation
					* Deal with contentions
					* join! and select!
					* Result and performance
					* Difference with Futures
				</script>
			</section>

			<section>
				<section data-markdown>
					<script type="text/template">
						## Stackful Generator
						
						* generator is a special function with multiple return values
						* `send`/`yeild` would swich stack context 
							```rust
							let mut g = Gn::new_scoped(|mut s| {
								s.yield_(17); //--> `yield` switch stack to caller
								              //--> `send` switch stack back from caller
								return 42;    //--> `return` finish the generator
								              //    and switch stack back to caller
							});
							g.for_each(|v| println!("{}", v); // print 17 and 42
							```
						Notes:
						compared with stack frame in normal funciton calls
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Context managment
						* thread local context stack and chain generators
						<div style="text-align: center;"><img src="images/context_stack_gen.png" style="background:none; border:none; box-shadow:none;"></div>
						Note: the root contains no stack but only regs
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## key features
						* detect current context type
						* `send` and `yield` with parameters
						* yield internal stack refs
						* always yiled to caller
					</script>
				</section>
			</section>

			<section>
				<section data-markdown>
					<script type="text/template">
						## Stackful Coroutine
						* coroutine is a special thread (user space / light)
						* scheduler running on multi-thread
						* semantic blocking is not real blocking
						* call API without directly yield
						* keep the same interface as std library
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Difference with generator
						* coroutine is a special generator
						* stackful coroutine can yeild from any point directly to scheduler
						* always yeild a "kernal request"
						* when resume the scheduler send back the result
						* init with Coroutine Local Storage

					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## user and kernel model
						<div style="text-align: center;"><img src="images/coroutine_stack.png" style="background:none; border:none; box-shadow:none;"></div>
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## the kernel request
						* coroutine signature
						```rust
						type CoroutineImpl = Generator<'static, EventResult, EventSubscriber>;
						```
						* the kernel request
						```rust
						// APIs running after yeild to scheduler
						pub trait EventSource {
							/// kernel handler of the event
							fn subscribe(&mut self, _c: CoroutineImpl);
							/// after yield back process
							fn yield_back(&self, cancel: &'static Cancel) {}
						}
						```
						* construct the kenel request on stack and yiled out
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## kernel request example
						```rust
						struct Sleep { dur: Duration }
						
						impl EventSource for Sleep {
							fn subscribe(&mut self, co: CoroutineImpl) {
								// put the coroutine into the timer list
								let sleep_co = Arc::new(AtomicOption::some(co));
								get_scheduler().add_timer(self.dur, sleep_co.clone());
							}
						}

						pub fn sleep(dur: Duration) {
							let sleeper = Sleep { dur };
							yield_with(&sleeper);
						}
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## uniform coroutine and generator
						```rust
						go!(|| {
							let g = Gn::new_scoped(|mut s| {
								for i in 0..1000 {
									// call coroutine API in generator, yield to scheduler
									coroutine::sleep(Duration::from_secs(1));
									// yield to caller
									s.yield_(i);
								}
								1000
							});
					
							g.for_each(|v| { dbg!(v); });
						})
						.wait()
						```
					</script>
				</section>
			</section>

			<section>
				<section data-markdown>
					<script type="text/template">
						## IO sub system
						* yield io kernel request
						* every io kernel request has a timeout property
						* running io related things only on io thread
						* support TCP/UDP/Unix Socket/Windows Pipe
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## the eventloop
						* uniform io event loop (epoll/kqueue/IOCP)
						* event mode: do the real io operation in user sapce after resume back
						* completion mode: check the io result after resume back
						* dispatch the io request on multiple io thread based on fd
						* io timeout is managed in the eventloop thread
						Note: stackful coroutine not using mio
					</script>
				</section>
			</section>

			<section style="text-align: left;">
				<h1>Thanks</h1>
				<p>
					- <a href="https://https://github.com/Xudong-Huang/generator-rs">stackful generator</a> <br>
					- <a href="https://github.com/Xudong-Huang/MAY">MAY</a>
				</p>
			</section>

		</div>

	</div>

	<script src="reveal.js/lib/js/head.min.js"></script>
	<script src="reveal.js/js/reveal.js"></script>

	<script>

		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
				{ src: 'reveal.js/lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'reveal.js/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'reveal.js/plugin/search/search.js', async: true },
				{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
				{ src: 'reveal.js/plugin/notes/notes.js', async: true }
			]
		});

	</script>

</body>

</html>